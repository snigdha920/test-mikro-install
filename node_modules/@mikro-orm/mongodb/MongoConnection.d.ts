import type { Collection, Db, MongoClientOptions, ClientSession } from 'mongodb';
import { MongoClient } from 'mongodb';
import type { ConnectionType, ConnectionConfig, QueryResult, Transaction, QueryOrderMap, FilterQuery, AnyEntity, EntityName, EntityData, TransactionEventBroadcaster, IsolationLevel, Configuration, ConnectionOptions } from '@mikro-orm/core';
import { Connection } from '@mikro-orm/core';
export declare class MongoConnection extends Connection {
    protected client: MongoClient;
    protected db: Db;
    private connected;
    constructor(config: Configuration, options?: ConnectionOptions, type?: ConnectionType);
    connect(): Promise<void>;
    close(force?: boolean): Promise<void>;
    isConnected(): Promise<boolean>;
    getCollection<T>(name: EntityName<T>): Collection<T>;
    createCollection<T>(name: EntityName<T>): Promise<Collection<T>>;
    listCollections(): Promise<string[]>;
    dropCollection(name: EntityName<AnyEntity>): Promise<boolean>;
    getDefaultClientUrl(): string;
    getConnectionOptions(): MongoClientOptions & ConnectionConfig;
    getClientUrl(): string;
    getDb(): Db;
    execute(query: string): Promise<any>;
    find<T extends AnyEntity<T>>(collection: string, where: FilterQuery<T>, orderBy?: QueryOrderMap<T> | QueryOrderMap<T>[], limit?: number, offset?: number, fields?: string[], ctx?: Transaction<ClientSession>): Promise<EntityData<T>[]>;
    insertOne<T>(collection: string, data: Partial<T>, ctx?: Transaction<ClientSession>): Promise<QueryResult<T>>;
    insertMany<T>(collection: string, data: Partial<T>[], ctx?: Transaction<ClientSession>): Promise<QueryResult<T>>;
    updateMany<T>(collection: string, where: FilterQuery<T>, data: Partial<T>, ctx?: Transaction<ClientSession>): Promise<QueryResult<T>>;
    bulkUpdateMany<T>(collection: string, where: FilterQuery<T>[], data: Partial<T>[], ctx?: Transaction<ClientSession>): Promise<QueryResult<T>>;
    deleteMany<T>(collection: string, where: FilterQuery<T>, ctx?: Transaction<ClientSession>): Promise<QueryResult<T>>;
    aggregate<T = any>(collection: string, pipeline: any[], ctx?: Transaction<ClientSession>): Promise<T[]>;
    countDocuments<T>(collection: string, where: FilterQuery<T>, ctx?: Transaction<ClientSession>): Promise<number>;
    transactional<T>(cb: (trx: Transaction<ClientSession>) => Promise<T>, options?: {
        isolationLevel?: IsolationLevel;
        ctx?: Transaction<ClientSession>;
        eventBroadcaster?: TransactionEventBroadcaster;
    }): Promise<T>;
    begin(options?: {
        isolationLevel?: IsolationLevel;
        ctx?: ClientSession;
        eventBroadcaster?: TransactionEventBroadcaster;
    }): Promise<ClientSession>;
    commit(ctx: ClientSession, eventBroadcaster?: TransactionEventBroadcaster): Promise<void>;
    rollback(ctx: ClientSession, eventBroadcaster?: TransactionEventBroadcaster): Promise<void>;
    private runQuery;
    private createUpdatePayload;
    private transformResult;
    private getCollectionName;
    private logObject;
}
