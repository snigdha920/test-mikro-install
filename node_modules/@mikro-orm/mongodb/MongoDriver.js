"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoDriver = void 0;
const bson_1 = require("bson");
const core_1 = require("@mikro-orm/core");
const MongoConnection_1 = require("./MongoConnection");
const MongoPlatform_1 = require("./MongoPlatform");
const MongoEntityManager_1 = require("./MongoEntityManager");
class MongoDriver extends core_1.DatabaseDriver {
    constructor(config) {
        super(config, ['mongodb']);
        this.connection = new MongoConnection_1.MongoConnection(this.config);
        this.platform = new MongoPlatform_1.MongoPlatform();
    }
    createEntityManager(useContext) {
        return new MongoEntityManager_1.MongoEntityManager(this.config, this, this.metadata, useContext);
    }
    async find(entityName, where, options = {}) {
        const fields = this.buildFields(entityName, options.populate || [], options.fields);
        where = this.renameFields(entityName, where, true);
        const res = await this.rethrow(this.getConnection('read').find(entityName, where, options.orderBy, options.limit, options.offset, fields, options.ctx));
        return res.map(r => this.mapResult(r, this.metadata.find(entityName)));
    }
    async findOne(entityName, where, options = { populate: [], orderBy: {} }) {
        if (core_1.Utils.isPrimaryKey(where)) {
            where = this.buildFilterById(entityName, where);
        }
        const fields = this.buildFields(entityName, options.populate || [], options.fields);
        where = this.renameFields(entityName, where, true);
        const res = await this.rethrow(this.getConnection('read').find(entityName, where, options.orderBy, 1, undefined, fields, options.ctx));
        return this.mapResult(res[0], this.metadata.find(entityName));
    }
    async count(entityName, where, options = {}, ctx) {
        where = this.renameFields(entityName, where, true);
        return this.rethrow(this.getConnection('read').countDocuments(entityName, where, ctx));
    }
    async nativeInsert(entityName, data, options = {}) {
        data = this.renameFields(entityName, data);
        return this.rethrow(this.getConnection('write').insertOne(entityName, data, options.ctx));
    }
    async nativeInsertMany(entityName, data, options = {}) {
        data = data.map(d => this.renameFields(entityName, d));
        const meta = this.metadata.find(entityName);
        /* istanbul ignore next */
        const pk = meta?.getPrimaryProps()[0].fieldNames[0] ?? '_id';
        const res = await this.rethrow(this.getConnection('write').insertMany(entityName, data, options.ctx));
        res.rows = res.insertedIds.map(id => ({ [pk]: id }));
        return res;
    }
    async nativeUpdate(entityName, where, data, options = {}) {
        if (core_1.Utils.isPrimaryKey(where)) {
            where = this.buildFilterById(entityName, where);
        }
        where = this.renameFields(entityName, where, true);
        data = this.renameFields(entityName, data);
        return this.rethrow(this.getConnection('write').updateMany(entityName, where, data, options.ctx));
    }
    async nativeUpdateMany(entityName, where, data, options = {}) {
        data = data.map(row => this.renameFields(entityName, row));
        return this.rethrow(this.getConnection('write').bulkUpdateMany(entityName, where, data, options.ctx));
    }
    async nativeDelete(entityName, where, options = {}) {
        if (core_1.Utils.isPrimaryKey(where)) {
            where = this.buildFilterById(entityName, where);
        }
        where = this.renameFields(entityName, where, true);
        return this.rethrow(this.getConnection('write').deleteMany(entityName, where, options.ctx));
    }
    async aggregate(entityName, pipeline, ctx) {
        return this.rethrow(this.getConnection('read').aggregate(entityName, pipeline, ctx));
    }
    getPlatform() {
        return this.platform;
    }
    renameFields(entityName, data, where = false) {
        data = Object.assign({}, data); // copy first
        core_1.Utils.renameKey(data, 'id', '_id');
        const meta = this.metadata.find(entityName);
        if (meta) {
            this.inlineEmbeddables(meta, data, where);
        }
        Object.keys(data).forEach(k => {
            if (core_1.Utils.isGroupOperator(k)) {
                /* istanbul ignore else */
                if (Array.isArray(data[k])) {
                    data[k] = data[k].map((v) => this.renameFields(entityName, v));
                }
                else {
                    data[k] = this.renameFields(entityName, data[k]);
                }
                return;
            }
            if (meta?.properties[k]) {
                const prop = meta.properties[k];
                let isObjectId = false;
                if (prop.reference === core_1.ReferenceType.SCALAR) {
                    isObjectId = prop.type.toLowerCase() === 'objectid';
                }
                else if (prop.reference !== core_1.ReferenceType.EMBEDDED) {
                    const meta2 = this.metadata.find(prop.type);
                    const pk = meta2.properties[meta2.primaryKeys[0]];
                    isObjectId = pk.type.toLowerCase() === 'objectid';
                }
                if (isObjectId) {
                    data[k] = this.convertObjectIds(data[k]);
                }
                if (prop.fieldNames) {
                    core_1.Utils.renameKey(data, k, prop.fieldNames[0]);
                }
            }
            if (core_1.Utils.isPlainObject(data[k]) && '$re' in data[k]) {
                data[k] = new RegExp(data[k].$re);
            }
        });
        return data;
    }
    convertObjectIds(data) {
        if (data instanceof bson_1.ObjectId) {
            return data;
        }
        if (core_1.Utils.isString(data) && data.match(/^[0-9a-f]{24}$/i)) {
            return new bson_1.ObjectId(data);
        }
        if (Array.isArray(data)) {
            return data.map((item) => this.convertObjectIds(item));
        }
        if (core_1.Utils.isObject(data)) {
            Object.keys(data).forEach(k => {
                data[k] = this.convertObjectIds(data[k]);
            });
        }
        return data;
    }
    buildFilterById(entityName, id) {
        const meta = this.metadata.find(entityName);
        if (meta.properties[meta.primaryKeys[0]].type.toLowerCase() === 'objectid') {
            return { _id: new bson_1.ObjectId(id) };
        }
        return { _id: id };
    }
    buildFields(entityName, populate, fields) {
        const meta = this.metadata.find(entityName);
        const lazyProps = meta.props.filter(prop => prop.lazy && !populate.some(p => p.field === prop.name || p.all));
        const ret = [];
        if (fields) {
            for (const field of fields) {
                if (core_1.Utils.isPlainObject(field) || field.toString().includes('.')) {
                    continue;
                }
                let prop = meta.properties[field];
                /* istanbul ignore else */
                if (prop) {
                    prop = prop.serializedPrimaryKey ? meta.getPrimaryProps()[0] : prop;
                    ret.push(prop.fieldNames[0]);
                }
                else if (field === '*') {
                    const props = meta.props.filter(prop => this.platform.shouldHaveColumn(prop, populate));
                    ret.push(...core_1.Utils.flatten(props.filter(p => !lazyProps.includes(p)).map(p => p.fieldNames)));
                }
                else {
                    ret.push(field);
                }
            }
            ret.unshift(...meta.primaryKeys.filter(pk => !fields.includes(pk)));
        }
        else if (lazyProps.filter(p => !p.formula).length > 0) {
            const props = meta.props.filter(prop => this.platform.shouldHaveColumn(prop, populate));
            ret.push(...core_1.Utils.flatten(props.filter(p => !lazyProps.includes(p)).map(p => p.fieldNames)));
        }
        return ret.length > 0 ? ret : undefined;
    }
    /**
     * @deprecated use `orm.getSchemaGenerator().createSchema()` instead
     */
    async createCollections() {
        await this.platform.getSchemaGenerator(this).createSchema();
    }
    /**
     * @deprecated use `orm.getSchemaGenerator().dropSchema()` instead
     */
    async dropCollections() {
        await this.platform.getSchemaGenerator(this).dropSchema();
    }
    /**
     * @deprecated use `orm.getSchemaGenerator().refreshDatabase()` instead
     */
    async refreshCollections(options = {}) {
        await this.platform.getSchemaGenerator(this).refreshDatabase(options);
    }
    /**
     * @deprecated use `orm.getSchemaGenerator().ensureIndexes()` instead
     */
    async ensureIndexes() {
        await this.platform.getSchemaGenerator(this).ensureIndexes();
    }
}
exports.MongoDriver = MongoDriver;
